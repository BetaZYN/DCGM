# Copyright (c) 2021, NVIDIA CORPORATION.  All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import linting

import tempfile
import os
import time
import option_parser
import test_utils

def test_linting_create_python_path_env_var():
    '''
    A unit test for linting.py's _create_python_path_env_var function.
    This tests that given a number of python filepaths it returns a python path
    that only includes the topmost directories containing python files.
    '''

    if not option_parser.options.lint:
        test_utils.skip_test("not supported when the \"--no-lint\" option is used")

    filepaths = [
        '/a/file1.py',
        '/a/file2.py',
        
        '/a2/b/file3.py',
        '/a2/b/c/file4.py',
        '/a2/b/c/d/file5.py'
    ]
    
    expectedPyPath = ':'.join([
        '/a',
        '/a2/b',
    ])
    
    actualPyPath = linting._create_python_path_env_var(filepaths)
    
    assert(actualPyPath == expectedPyPath), (
        'actual python path:\n%s\n' % actualPyPath
        + 'not the same as expected:\n%s' % expectedPyPath)  
    
def test_linting_get_py_files_to_lint():
    '''
    A unit test for linting.py's _get_py_files_to_lint function.
    It tests that:
      - if a python file has no .pylint-passed file then it is linted
      - if a .pylint-passed file modify time is older than its python file 
        then it is linted
      - otherwise the file is not selected for linting
    '''

    if not option_parser.options.lint:
        test_utils.skip_test("not supported when the \"--no-lint\" option is used")

    notYetLinted = 'notYetLinted.py'
    oldLinted = 'oldLinted.py'
    newLinted = 'newLinted.py'
    
    tmpDir = tempfile.mkdtemp()
    
    def pylint_file(pyFile):
        return '.%s.pylint-passed' % pyFile
    
    # set up the py/pylint-passed files with the proper modification times
    for file in [notYetLinted, 
                 pylint_file(oldLinted), oldLinted, 
                 newLinted, pylint_file(newLinted)]:
        
        fp = os.path.join(tmpDir, file)
        with open(fp, 'a'):
            os.utime(fp, None)
        time.sleep(0.005)   # must wait so that modification time changes
            
    filesToLint = linting._get_py_files_to_lint(tmpDir)
    expectedFilesToLint = [
        os.path.join(tmpDir, file) for file in [notYetLinted, oldLinted]
    ]
    
    unexpectedFilesToLint = set(filesToLint) - set(expectedFilesToLint)
    assert len(unexpectedFilesToLint) == 0, \
        "These python files should not have been linted: %s" % unexpectedFilesToLint
        
    expectedFilesNotLinted = set(expectedFilesToLint) - set(filesToLint)
    assert len(expectedFilesNotLinted) == 0, \
        "These python files should have been linted: %s" % expectedFilesNotLinted
    
def test_linting_clear_lint_artifacts():
    '''
    A unit test for linting.py's _clear_lint_artifacts function.
    It tests that it actually clears any artifact files that were generated by pylint.
    '''
    
    if not option_parser.options.lint:
        test_utils.skip_test("not supported when the \"--no-lint\" option is used")

    tmpDir = tempfile.mkdtemp()
    artifactFile = os.path.join(tmpDir, '.file.py.pylint-passed')
    with open(artifactFile, 'w'):
        os.utime(artifactFile, None)
        
    assert os.path.isfile(artifactFile), 'Failed to create file for testing'
    
    linting._clear_lint_artifacts(tmpDir)
    
    assert not os.path.isfile(artifactFile), 'pylint artifact was not removed'
    
